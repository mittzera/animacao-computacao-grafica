'use client'

import React, { useRef, useEffect, useState } from 'react'
import * as THREE from 'three'
import { CharacterRig } from '@/lib/character-rig'
import { IKSolver, FKController, HingeJoint } from '@/lib/animation-systems'
import { CinematicCamera } from '@/lib/cinematic-camera'
import { VisualEffects } from '@/lib/visual-effects'
import { ANIMATION_CONFIG, ANIMATION_UTILS } from '@/utils/animation-config'

interface FootballAnimationProps {
  onAnimationComplete?: () => void
}

const FootballAnimation: React.FC<FootballAnimationProps> = ({ onAnimationComplete }) => {
  const mountRef = useRef<HTMLDivElement>(null)
  const sceneRef = useRef<THREE.Scene>()
  const rendererRef = useRef<THREE.WebGLRenderer>()
  const cameraRef = useRef<THREE.PerspectiveCamera>()
  const characterRef = useRef<CharacterRig>()
  const ballRef = useRef<THREE.Mesh>()
  const animationIdRef = useRef<number | null>(null)
  
  const [isPlaying, setIsPlaying] = useState(false)
  const [animationTime, setAnimationTime] = useState(0)
  const [currentPhase, setCurrentPhase] = useState('Preparando...')
  
  // Controllers
  const fkControllerRef = useRef<FKController>()
  const ikSolverRef = useRef<IKSolver>()
  const hingeJointsRef = useRef<HingeJoint[]>()
  const cinematicCameraRef = useRef<CinematicCamera>()
  const visualEffectsRef = useRef<VisualEffects>()
  
  // Effect triggers
  const lastDustTime = useRef(0)
  const kickEffectTriggered = useRef(false)
  const celebrationEffectTriggered = useRef(false)

  useEffect(() => {
    if (!mountRef.current) return

    // Setup scene
    const scene = new THREE.Scene()
    scene.background = new THREE.Color(0x87CEEB) // Sky blue
    sceneRef.current = scene

    // Setup camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
    camera.position.set(0, 2, 5)
    camera.lookAt(0, 1, 0)
    cameraRef.current = camera

    // Setup renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true })
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.shadowMap.enabled = true
    renderer.shadowMap.type = THREE.PCFSoftShadowMap
    rendererRef.current = renderer
    mountRef.current.appendChild(renderer.domElement)

    // Setup lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6)
    scene.add(ambientLight)

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
    directionalLight.position.set(10, 10, 5)
    directionalLight.castShadow = true
    directionalLight.shadow.mapSize.width = 2048
    directionalLight.shadow.mapSize.height = 2048
    scene.add(directionalLight)

    // Create ground
    const groundGeometry = new THREE.PlaneGeometry(20, 20)
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x00AA00 })
    const ground = new THREE.Mesh(groundGeometry, groundMaterial)
    ground.rotation.x = -Math.PI / 2
    ground.receiveShadow = true
    scene.add(ground)

    // Create football field markings
    const lineGeometry = new THREE.PlaneGeometry(0.1, 10)
    const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff })
    const centerLine = new THREE.Mesh(lineGeometry, lineMaterial)
    centerLine.rotation.x = -Math.PI / 2
    centerLine.position.y = 0.01
    scene.add(centerLine)

    // Create goal
    const goalGeometry = new THREE.BoxGeometry(3, 2, 0.1)
    const goalMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff })
    const goal = new THREE.Mesh(goalGeometry, goalMaterial)
    goal.position.set(0, 1, -8)
    scene.add(goal)

    // Create football
    const ballGeometry = new THREE.SphereGeometry(0.15, 16, 16)
    const ballMaterial = new THREE.MeshLambertMaterial({ 
      color: 0x000000,
      transparent: true,
      opacity: 0.8
    })
    
    // Add football pattern
    const ballGroup = new THREE.Group()
    const ball = new THREE.Mesh(ballGeometry, ballMaterial)
    
    // White pentagons
    const pentagonGeometry = new THREE.RingGeometry(0.05, 0.08, 5)
    const pentagonMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff })
    
    for (let i = 0; i < 12; i++) {
      const pentagon = new THREE.Mesh(pentagonGeometry, pentagonMaterial)
      const phi = Math.random() * Math.PI * 2
      const theta = Math.random() * Math.PI
      pentagon.position.setFromSphericalCoords(0.16, theta, phi)
      pentagon.lookAt(0, 0, 0)
      ballGroup.add(pentagon)
    }
    
    ballGroup.add(ball)
    ballGroup.position.set(0, 0.15, 2)
    ballGroup.castShadow = true
    ballRef.current = ball
    scene.add(ballGroup)

    // Create character
    const character = new CharacterRig()
    const characterMesh = character.getMesh()
    characterMesh.castShadow = true
    characterMesh.receiveShadow = true
    scene.add(characterMesh)
    characterRef.current = character

    // Setup animation controllers
    const bones = [
      character.getBone('rightThigh')!,
      character.getBone('rightShin')!,
      character.getBone('leftThigh')!,
      character.getBone('leftShin')!,
      character.getBone('rightArm')!,
      character.getBone('leftArm')!
    ]
    
    fkControllerRef.current = new FKController(bones)

    // Setup IK for leg
    const legChain = [
      character.getBone('rightThigh')!,
      character.getBone('rightShin')!,
      character.getBone('rightFoot')!
    ]
    const ikTarget = new THREE.Vector3(0.5, 0, 1.5)
    ikSolverRef.current = new IKSolver(legChain, ikTarget)    // Setup hinge joints
    hingeJointsRef.current = [
      new HingeJoint(character.getBone('rightShin')!, new THREE.Vector3(1, 0, 0), 0, Math.PI),
      new HingeJoint(character.getBone('leftShin')!, new THREE.Vector3(1, 0, 0), 0, Math.PI),
      new HingeJoint(character.getBone('rightForearm')!, new THREE.Vector3(0, 0, 1), -Math.PI/2, Math.PI/2),
      new HingeJoint(character.getBone('leftForearm')!, new THREE.Vector3(0, 0, 1), -Math.PI/2, Math.PI/2)
    ]

    // Setup cinematic camera
    cinematicCameraRef.current = new CinematicCamera(camera)
    
    // Setup visual effects
    visualEffectsRef.current = new VisualEffects(scene)

    // Handle window resize
    const handleResize = () => {
      if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      }
    }
    window.addEventListener('resize', handleResize)

    return () => {
      window.removeEventListener('resize', handleResize)
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current)
      }
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement)
      }
      renderer.dispose()
    }  }, [])
  const animate = () => {
    if (!sceneRef.current || !rendererRef.current || !cameraRef.current || !characterRef.current) {
      console.log('Missing refs:', {
        scene: !!sceneRef.current,
        renderer: !!rendererRef.current,
        camera: !!cameraRef.current,
        character: !!characterRef.current
      })
      // Retry in next frame if refs aren't ready
      if (isPlaying) {
        animationIdRef.current = requestAnimationFrame(animate)
      }
      return
    }

    const time = animationTime * 0.001
    const character = characterRef.current
    
    console.log('Animating...', { time, animationTime, isPlaying })
    
    // Animation phases (total 18 seconds)
    const totalDuration = ANIMATION_CONFIG.TOTAL_DURATION
    const phase = (time % totalDuration) / totalDuration
    
    if (phase < ANIMATION_CONFIG.PHASES.RUN.end) {
      // Phase 1: Running towards ball - FK
      setCurrentPhase('Correndo para a bola')
      const phaseProgress = ANIMATION_UTILS.getPhaseProgress(phase, ANIMATION_CONFIG.PHASES.RUN)
      const runTime = phaseProgress * 6
      fkControllerRef.current?.animateWalk(runTime)
      
      // Move character forward
      character.getMesh().position.z = ANIMATION_UTILS.lerp(
        ANIMATION_CONFIG.POSITIONS.CHARACTER_START_Z, 
        0, 
        phaseProgress
      )
      
      // Add running dust effects
      if (time - lastDustTime.current > 0.3) {
        visualEffectsRef.current?.createRunningDust(character.getMesh().position)
        lastDustTime.current = time
      }
      
    } else if (phase < ANIMATION_CONFIG.PHASES.PREPARE.end) {
      // Phase 2: Preparing to kick - IK
      setCurrentPhase('Preparando o chute')
      const phaseProgress = ANIMATION_UTILS.getPhaseProgress(phase, ANIMATION_CONFIG.PHASES.PREPARE)
      
      // Use IK to position leg for kick
      const targetX = ANIMATION_CONFIG.IK.TARGET_POSITIONS.PREPARE_X + 
                     ANIMATION_UTILS.smoothWave(phaseProgress * Math.PI) * 0.5
      const targetZ = ANIMATION_UTILS.lerp(
        ANIMATION_CONFIG.IK.TARGET_POSITIONS.PREPARE_Z_START,
        ANIMATION_CONFIG.IK.TARGET_POSITIONS.PREPARE_Z_END,
        phaseProgress
      )
      ikSolverRef.current!.target.set(targetX, 0.2, targetZ)
      ikSolverRef.current?.solve()
      
      // Position character for kick
      character.getMesh().position.z = 0.5
      
    } else if (phase < ANIMATION_CONFIG.PHASES.KICK.end) {
      // Phase 3: Kicking motion - Hinge joints
      setCurrentPhase('Chutando a bola')
      const phaseProgress = ANIMATION_UTILS.getPhaseProgress(phase, ANIMATION_CONFIG.PHASES.KICK)
      const kickTime = phaseProgress * ANIMATION_CONFIG.HINGES.KICK_INTENSITY
      
      // Animate kick with hinge joints
      hingeJointsRef.current?.forEach((hinge, index) => {
        if (index === 0) { // Right shin for kick
          hinge.animateKick(kickTime, phaseProgress * Math.PI)
        }
      })
      
      // Trigger kick impact effect
      if (phaseProgress > 0.4 && phaseProgress < 0.6 && !kickEffectTriggered.current) {
        const ballPosition = ballRef.current?.parent?.position
        if (ballPosition) {
          visualEffectsRef.current?.createKickImpact(ballPosition.clone())
          kickEffectTriggered.current = true
        }
      }
      
      // Move ball during kick
      if (phaseProgress > 0.5 && ballRef.current) {
        const ballProgress = (phaseProgress - 0.5) * 2
        const newZ = ANIMATION_UTILS.lerp(
          ANIMATION_CONFIG.POSITIONS.BALL_START.z,
          ANIMATION_CONFIG.POSITIONS.BALL_START.z - ANIMATION_CONFIG.POSITIONS.BALL_END_DISTANCE,
          ballProgress
        )
        ballRef.current.parent!.position.z = newZ
        ballRef.current.parent!.position.y = ANIMATION_CONFIG.POSITIONS.BALL_START.y + 
                                             ballProgress * ANIMATION_CONFIG.POSITIONS.BALL_HEIGHT_MULTIPLIER
        
        // Create ball trail
        if (ballProgress === 0 && kickEffectTriggered.current) {
          const startPos = new THREE.Vector3(0, 0.15, 2)
          const endPos = new THREE.Vector3(0, 2, -8)
          visualEffectsRef.current?.createBallTrail(startPos, endPos)
        }
      }
      
    } else {
      // Phase 4: Follow through and celebration - Combined FK/IK
      setCurrentPhase('Comemorando o gol!')
      const phaseProgress = ANIMATION_UTILS.getPhaseProgress(phase, ANIMATION_CONFIG.PHASES.CELEBRATE)
      
      // Trigger celebration confetti
      if (phaseProgress > 0.2 && !celebrationEffectTriggered.current) {
        visualEffectsRef.current?.createCelebrationConfetti(character.getMesh().position)
        celebrationEffectTriggered.current = true
      }
      
      // Celebration animation
      const celebrationTime = phaseProgress * ANIMATION_CONFIG.MOVEMENT.CELEBRATION_SPEED
      
      // Arms celebration - FK
      if (character.getBone('rightArm')) {
        character.getBone('rightArm')!.rotation.z = ANIMATION_UTILS.smoothWave(
          celebrationTime * 3, 1, 0.5
        )
      }
      if (character.getBone('leftArm')) {
        character.getBone('leftArm')!.rotation.z = ANIMATION_UTILS.smoothWave(
          celebrationTime * 3, 1, -0.5
        )
      }
      
      // Jump - IK for legs
      const jumpHeight = Math.abs(ANIMATION_UTILS.smoothWave(celebrationTime * 2)) * 
                        ANIMATION_CONFIG.MOVEMENT.JUMP_HEIGHT
      character.getMesh().position.y = jumpHeight
    }

    // Update cinematic camera
    cinematicCameraRef.current?.updateCameraForPhase(phase, time, character.getMesh().position)

    // Update skeleton
    character.getSkeleton().calculateInverses()

    // Render
    rendererRef.current.render(sceneRef.current, cameraRef.current)

    if (isPlaying) {
      setAnimationTime(prev => prev + 16) // ~60fps
      animationIdRef.current = requestAnimationFrame(animate)
        // Check if animation completed
      if (time >= ANIMATION_CONFIG.TOTAL_DURATION && onAnimationComplete) {
        onAnimationComplete()
      }
    }
  }
  const startAnimation = () => {
    console.log('Starting animation...')
    setIsPlaying(true)
    setAnimationTime(0)
    setCurrentPhase('Preparando...')
    // Force start the animation loop
    requestAnimationFrame(animate)
  }

  const stopAnimation = () => {
    setIsPlaying(false)
    if (animationIdRef.current) {
      cancelAnimationFrame(animationIdRef.current)
    }
  }

  const resetAnimation = () => {
    stopAnimation()
    setAnimationTime(0)
    
    // Reset character and ball positions
    if (characterRef.current) {
      characterRef.current.getMesh().position.set(0, 0, 0)
      // Reset all bone rotations
      Object.values(characterRef.current.bones).forEach(bone => {
        bone.rotation.set(0, 0, 0)
      })
    }
      if (ballRef.current) {
      ballRef.current.parent!.position.set(
        ANIMATION_CONFIG.POSITIONS.BALL_START.x,
        ANIMATION_CONFIG.POSITIONS.BALL_START.y,
        ANIMATION_CONFIG.POSITIONS.BALL_START.z
      )
    }
    
    // Render one frame    if (sceneRef.current && rendererRef.current && cameraRef.current) {
      rendererRef.current.render(sceneRef.current, cameraRef.current)
    }
  }

  useEffect(() => {
    if (isPlaying) {
      console.log('useEffect: Starting animation...')
      animationIdRef.current = requestAnimationFrame(animate)
    } else {
      console.log('useEffect: Stopping animation...')
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current)
        animationIdRef.current = null
      }
    }
  }, [isPlaying]) // Only depend on isPlaying

  return (
    <div className="relative w-full h-screen">
      <div ref={mountRef} className="w-full h-full" />
      
      <div className="controls">
        <h3 className="text-lg font-bold mb-4">Controles da Animação</h3>
        <div className="space-y-2">
          <button onClick={startAnimation} disabled={isPlaying}>
            Iniciar Animação
          </button>
          <button onClick={stopAnimation} disabled={!isPlaying}>
            Pausar
          </button>
          <button onClick={resetAnimation}>
            Resetar
          </button>
        </div>
          <div className="mt-4 text-sm">
          <p><strong>Tempo:</strong> {(animationTime / 1000).toFixed(1)}s / 18.0s</p>
          <p className="mt-2 text-xs">
            <strong>Fases:</strong><br/>
            0-5.4s: Corrida (FK)<br/>
            5.4-9s: Preparação (IK)<br/>
            9-12.6s: Chute (Hinges)<br/>
            12.6-18s: Comemoração (FK+IK)
          </p>
        </div>
      </div>
    </div>
  )
}

export default FootballAnimation
