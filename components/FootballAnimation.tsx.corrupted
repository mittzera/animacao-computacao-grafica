'use client'

import React, { useRef, useEffect, useState } from 'react'
import * as THREE from 'three'
import { CharacterRig } from '@/lib/character-rig'
import { IKSolver, FKController, HingeJoint } from '@/lib/animation-systems'
import { CinematicCamera } from '@/lib/cinematic-camera'
import { VisualEffects } from '@/lib/visual-effects'
import { ANIMATION_CONFIG, ANIMATION_UTILS } from '@/utils/animation-config'

interface FootballAnimationProps {
  onAnimationComplete?: () => void
}

const FootballAnimation: React.FC<FootballAnimationProps> = ({ onAnimationComplete }) => {
  const mountRef = useRef<HTMLDivElement>(null)
  const sceneRef = useRef<THREE.Scene>()
  const rendererRef = useRef<THREE.WebGLRenderer>()
  const cameraRef = useRef<THREE.PerspectiveCamera>()
  const characterRef = useRef<CharacterRig>()
  const ballRef = useRef<THREE.Mesh>()
  const animationIdRef = useRef<number | null>(null)
  
  const [isPlaying, setIsPlaying] = useState(false)
  const [animationTime, setAnimationTime] = useState(0)
  const [currentPhase, setCurrentPhase] = useState('Preparando...')
  
  // Controllers
  const fkControllerRef = useRef<FKController>()
  const ikSolverRef = useRef<IKSolver>()
  const hingeJointsRef = useRef<HingeJoint[]>()
  const cinematicCameraRef = useRef<CinematicCamera>()
  const visualEffectsRef = useRef<VisualEffects>()
  
  // Effect triggers
  const lastDustTime = useRef(0)
  const kickEffectTriggered = useRef(false)
  const celebrationEffectTriggered = useRef(false)

  useEffect(() => {
    if (!mountRef.current) return

    // Setup scene
    const scene = new THREE.Scene()
    scene.background = new THREE.Color(0x87CEEB)
    sceneRef.current = scene

    // Setup camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
    camera.position.set(0, 2, 5)
    camera.lookAt(0, 1, 0)
    cameraRef.current = camera

    // Setup renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true })
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.shadowMap.enabled = true
    renderer.shadowMap.type = THREE.PCFSoftShadowMap
    mountRef.current.appendChild(renderer.domElement)
    rendererRef.current = renderer    // Add lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6)
    scene.add(ambientLight)
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
    directionalLight.position.set(10, 10, 5)
    directionalLight.castShadow = true
    directionalLight.shadow.mapSize.width = 2048
    directionalLight.shadow.mapSize.height = 2048
    scene.add(directionalLight)
    
    // Add warm sunset lighting
    const sunsetLight = new THREE.DirectionalLight(0xffa500, 0.3)
    sunsetLight.position.set(-10, 5, -5)
    scene.add(sunsetLight)    // Create field
    const fieldGeometry = new THREE.PlaneGeometry(20, 15)
    const fieldMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 })
    const field = new THREE.Mesh(fieldGeometry, fieldMaterial)
    field.rotation.x = -Math.PI / 2
    field.receiveShadow = true
    scene.add(field)
      // Add field lines
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff })
    
    // Center circle
    const circlePoints = []
    for (let i = 0; i <= 32; i++) {
      const angle = (i / 32) * Math.PI * 2
      circlePoints.push(new THREE.Vector3(
        Math.cos(angle) * 2,
        0.01,
        Math.sin(angle) * 2
      ))
    }
    const circleGeometry = new THREE.BufferGeometry().setFromPoints(circlePoints)
    const circle = new THREE.Line(circleGeometry, lineMaterial)
    scene.add(circle)
    
    // Goal area lines
    const goalLineGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-3, 0.01, -7),
      new THREE.Vector3(3, 0.01, -7),
      new THREE.Vector3(3, 0.01, -5),
      new THREE.Vector3(-3, 0.01, -5),
      new THREE.Vector3(-3, 0.01, -7)
    ])
    const goalLines = new THREE.Line(goalLineGeometry, lineMaterial)
    scene.add(goalLines)

    // Create character
    const character = new CharacterRig()
    scene.add(character.getMesh())
    characterRef.current = character    // Create ball
    const ballGeometry = new THREE.SphereGeometry(0.15, 32, 32)
    const ballMaterial = new THREE.MeshPhongMaterial({ 
      color: 0xffffff,
      shininess: 100,
      specular: 0x111111
    })
    const ball = new THREE.Mesh(ballGeometry, ballMaterial)
    ball.position.set(0, 0.15, 2)
    ball.castShadow = true
    scene.add(ball)
    ballRef.current = ball

    // Initialize controllers
    const bones = [
      character.getBone('rightThigh')!,
      character.getBone('rightShin')!,
      character.getBone('leftThigh')!,
      character.getBone('leftShin')!,
      character.getBone('rightArm')!,
      character.getBone('leftArm')!
    ]
    
    fkControllerRef.current = new FKController(bones)

    // Setup IK for leg
    const legChain = [
      character.getBone('rightThigh')!,
      character.getBone('rightShin')!,
      character.getBone('rightFoot')!
    ]
    const ikTarget = new THREE.Vector3(0.5, 0, 1.5)
    ikSolverRef.current = new IKSolver(legChain, ikTarget)
    
    cinematicCameraRef.current = new CinematicCamera(camera)
    visualEffectsRef.current = new VisualEffects(scene)
    
    // Initialize hinge joints for knees and elbows
    hingeJointsRef.current = [
      new HingeJoint(character.getBone('rightShin')!, new THREE.Vector3(1, 0, 0), 0, Math.PI * 0.8),
      new HingeJoint(character.getBone('leftShin')!, new THREE.Vector3(1, 0, 0), 0, Math.PI * 0.8),
      new HingeJoint(character.getBone('rightForearm')!, new THREE.Vector3(0, 1, 0), -Math.PI * 0.7, Math.PI * 0.7),
      new HingeJoint(character.getBone('leftForearm')!, new THREE.Vector3(0, 1, 0), -Math.PI * 0.7, Math.PI * 0.7)    ]

    // Define animate function inside useEffect
    const animate = () => {
      if (!sceneRef.current || !rendererRef.current || !cameraRef.current || !characterRef.current || !isPlaying) {
        return
      }

      const time = animationTime * 0.001
      const character = characterRef.current
      const ball = ballRef.current!
      
      // Determine animation phase (18 seconds total)
      const totalDuration = 18
      const phase = time / totalDuration
      
      let currentPhaseText = 'Preparando...'
      
      if (phase < 0.3) {
        // Phase 1: Running (0-5.4s) - Forward Kinematics
        currentPhaseText = 'Correndo (FK)'
        
        // FK running animation
        const runTime = time * 3
        if (fkControllerRef.current) {
          // Leg animation
          character.getBone('rightThigh')!.rotation.x = Math.sin(runTime) * 0.5
          character.getBone('leftThigh')!.rotation.x = -Math.sin(runTime) * 0.5
          character.getBone('rightShin')!.rotation.x = Math.max(0, Math.sin(runTime + 0.5)) * 0.3
          character.getBone('leftShin')!.rotation.x = Math.max(0, -Math.sin(runTime + 0.5)) * 0.3
          
          // Arm animation
          character.getBone('rightArm')!.rotation.x = -Math.sin(runTime) * 0.3
          character.getBone('leftArm')!.rotation.x = Math.sin(runTime) * 0.3
        }
        
        // Move character forward
        character.getMesh().position.z = -time * 1.5
        
        // Running dust effects
        if (visualEffectsRef.current && time - lastDustTime.current > 0.3) {
          const pos = new THREE.Vector3().copy(character.getMesh().position)
          pos.y = 0.1
          visualEffectsRef.current.createRunningDust(pos)
          lastDustTime.current = time
        }
        
      } else if (phase < 0.5) {
        // Phase 2: Kick preparation (5.4-9s) - Inverse Kinematics  
        currentPhaseText = 'Preparando chute (IK)'
        
        // Use IK to position leg for kicking
        if (ikSolverRef.current) {
          const kickTarget = new THREE.Vector3(0.3, 0.2, character.getMesh().position.z + 1.5)
          ikSolverRef.current.target.copy(kickTarget)
          ikSolverRef.current.solve()
        }
        
        // Preparation stance
        character.getBone('leftThigh')!.rotation.x = -0.2
        character.getBone('leftShin')!.rotation.x = 0.1
        character.getBone('rightArm')!.rotation.x = -0.5
        character.getBone('leftArm')!.rotation.x = 0.5
        
      } else if (phase < 0.7) {
        // Phase 3: Kicking (9-12.6s) - Hinge Joints
        currentPhaseText = 'Chutando (Hinge Joints)'
        
        // Apply hinge joint constraints during kick
        if (hingeJointsRef.current) {
          const kickPhase = (phase - 0.5) / 0.2 // 0 to 1 over kick duration
          const kickAngle = Math.sin(kickPhase * Math.PI) * 1.2
          
          // Apply to knee joints
          hingeJointsRef.current[0].setAngle(kickAngle) // right knee
          hingeJointsRef.current[1].setAngle(kickAngle * 0.5) // left knee
        }
        
        // Kick motion
        const kickPhase = (phase - 0.5) / 0.2 // 0 to 1 over kick duration
        const kickAngle = Math.sin(kickPhase * Math.PI) * 1.2
        
        character.getBone('rightThigh')!.rotation.x = kickAngle
        character.getBone('rightShin')!.rotation.x = Math.max(0, kickAngle * 0.8)
        
        // Ball movement during kick
        if (kickPhase > 0.5 && !kickEffectTriggered.current) {
          // Realistic ball trajectory with gravity
          const ballFlightTime = time - 9 // Time since kick started
          const initialVelocityX = 2
          const initialVelocityY = 8
          const initialVelocityZ = 15
          const gravity = -9.8
          
          ball.position.set(
            character.getMesh().position.x + initialVelocityX * ballFlightTime,
            Math.max(0.15, 0.15 + initialVelocityY * ballFlightTime + 0.5 * gravity * ballFlightTime * ballFlightTime),
            character.getMesh().position.z + initialVelocityZ * ballFlightTime
          )
          
          // Kick impact effect
          if (visualEffectsRef.current) {
            visualEffectsRef.current.createKickImpact(ball.position.clone())
          }
          kickEffectTriggered.current = true
        }
        
      } else {
        // Phase 4: Celebration (12.6-18s) - Combined FK + IK
        currentPhaseText = 'Comemorando (FK + IK)'
        
        // Celebration animation combining techniques
        const celebTime = time * 2
        
        // FK for body movement
        character.getBone('spine')!.rotation.z = Math.sin(celebTime) * 0.2
        character.getBone('head')!.rotation.y = Math.sin(celebTime * 1.5) * 0.3
        
        // IK for arm positioning
        character.getBone('rightArm')!.rotation.z = Math.PI * 0.3 + Math.sin(celebTime) * 0.2
        character.getBone('leftArm')!.rotation.z = -Math.PI * 0.3 - Math.sin(celebTime) * 0.2
        character.getBone('rightArm')!.rotation.x = Math.sin(celebTime * 0.5) * 0.1
        character.getBone('leftArm')!.rotation.x = Math.sin(celebTime * 0.5) * 0.1
        
        // Celebration effects
        if (visualEffectsRef.current && !celebrationEffectTriggered.current) {
          const pos = new THREE.Vector3().copy(character.getMesh().position)
          pos.y = 2
          visualEffectsRef.current.createCelebrationConfetti(pos)
          celebrationEffectTriggered.current = true
        }
      }
      
      // Update cinematic camera
      if (cinematicCameraRef.current) {
        cinematicCameraRef.current.updateCameraForPhase(phase, time, character.getMesh().position)
      }
      
      // Update current phase display
      setCurrentPhase(currentPhaseText)

      // Render
      rendererRef.current.render(sceneRef.current, cameraRef.current)

      // Check if animation is complete
      if (time >= totalDuration) {
        setIsPlaying(false)
        if (onAnimationComplete) {
          onAnimationComplete()
        }
      } else {
        setAnimationTime(prev => prev + 16)
        animationIdRef.current = requestAnimationFrame(animate)
      }
    }

    return () => {
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current)
      }
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement)
      }
      renderer.dispose()
    }
  }, [isPlaying, animationTime])

  const startAnimation = () => {
    console.log('Starting animation...')
    setIsPlaying(true)
    setAnimationTime(0)
    
    // Start the animation loop
    if (!animationIdRef.current) {
      const animate = () => {
        if (!sceneRef.current || !rendererRef.current || !cameraRef.current || !characterRef.current) {
          return
        }

        const time = animationTime * 0.001
        const character = characterRef.current
        const ball = ballRef.current!
        
        // Determine animation phase (18 seconds total)
        const totalDuration = 18
        const phase = time / totalDuration
        
        let currentPhaseText = 'Preparando...'
        
        if (phase < 0.3) {
      // Phase 1: Running (0-5.4s) - Forward Kinematics
      currentPhaseText = 'Correndo (FK)'
      
      // FK running animation
      const runTime = time * 3
      if (fkControllerRef.current) {
        // Leg animation
        character.getBone('rightThigh')!.rotation.x = Math.sin(runTime) * 0.5
        character.getBone('leftThigh')!.rotation.x = -Math.sin(runTime) * 0.5
        character.getBone('rightShin')!.rotation.x = Math.max(0, Math.sin(runTime + 0.5)) * 0.3
        character.getBone('leftShin')!.rotation.x = Math.max(0, -Math.sin(runTime + 0.5)) * 0.3
        
        // Arm animation
        character.getBone('rightArm')!.rotation.x = -Math.sin(runTime) * 0.3
        character.getBone('leftArm')!.rotation.x = Math.sin(runTime) * 0.3
      }
      
      // Move character forward
      character.getMesh().position.z = -time * 1.5
        // Running dust effects
      if (visualEffectsRef.current && time - lastDustTime.current > 0.3) {
        const pos = new THREE.Vector3().copy(character.getMesh().position)
        pos.y = 0.1
        visualEffectsRef.current.createRunningDust(pos)
        lastDustTime.current = time
      }
      
    } else if (phase < 0.5) {
      // Phase 2: Kick preparation (5.4-9s) - Inverse Kinematics  
      currentPhaseText = 'Preparando chute (IK)'
      
      // Use IK to position leg for kicking
      if (ikSolverRef.current) {
        const kickTarget = new THREE.Vector3(0.3, 0.2, character.getMesh().position.z + 1.5)
        ikSolverRef.current.target.copy(kickTarget)
        ikSolverRef.current.solve()
      }
      
      // Preparation stance
      character.getBone('leftThigh')!.rotation.x = -0.2
      character.getBone('leftShin')!.rotation.x = 0.1
      character.getBone('rightArm')!.rotation.x = -0.5
      character.getBone('leftArm')!.rotation.x = 0.5
      
    } else if (phase < 0.7) {
      // Phase 3: Kicking (9-12.6s) - Hinge Joints
      currentPhaseText = 'Chutando (Hinge Joints)'
        // Apply hinge joint constraints during kick
      if (hingeJointsRef.current) {
        const kickPhase = (phase - 0.5) / 0.2 // 0 to 1 over kick duration
        const kickAngle = Math.sin(kickPhase * Math.PI) * 1.2
        
        // Apply to knee joints
        hingeJointsRef.current[0].setAngle(kickAngle) // right knee
        hingeJointsRef.current[1].setAngle(kickAngle * 0.5) // left knee
      }
      
      // Kick motion
      const kickPhase = (phase - 0.5) / 0.2 // 0 to 1 over kick duration
      const kickAngle = Math.sin(kickPhase * Math.PI) * 1.2
      
      character.getBone('rightThigh')!.rotation.x = kickAngle
      character.getBone('rightShin')!.rotation.x = Math.max(0, kickAngle * 0.8)
        // Ball movement during kick
      if (kickPhase > 0.5 && !kickEffectTriggered.current) {
        // Realistic ball trajectory with gravity
        const ballFlightTime = time - 9 // Time since kick started
        const initialVelocityX = 2
        const initialVelocityY = 8
        const initialVelocityZ = 15
        const gravity = -9.8
        
        ball.position.set(
          character.getMesh().position.x + initialVelocityX * ballFlightTime,
          Math.max(0.15, 0.15 + initialVelocityY * ballFlightTime + 0.5 * gravity * ballFlightTime * ballFlightTime),
          character.getMesh().position.z + initialVelocityZ * ballFlightTime
        )
        
        // Kick impact effect
        if (visualEffectsRef.current) {
          visualEffectsRef.current.createKickImpact(ball.position.clone())
        }
        kickEffectTriggered.current = true
      }
      
    } else {
      // Phase 4: Celebration (12.6-18s) - Combined FK + IK
      currentPhaseText = 'Comemorando (FK + IK)'
      
      // Celebration animation combining techniques
      const celebTime = time * 2
      
      // FK for body movement
      character.getBone('spine')!.rotation.z = Math.sin(celebTime) * 0.2
      character.getBone('head')!.rotation.y = Math.sin(celebTime * 1.5) * 0.3
      
      // IK for arm positioning
      character.getBone('rightArm')!.rotation.z = Math.PI * 0.3 + Math.sin(celebTime) * 0.2
      character.getBone('leftArm')!.rotation.z = -Math.PI * 0.3 - Math.sin(celebTime) * 0.2
      character.getBone('rightArm')!.rotation.x = Math.sin(celebTime * 0.5) * 0.1
      character.getBone('leftArm')!.rotation.x = Math.sin(celebTime * 0.5) * 0.1
        // Celebration effects
      if (visualEffectsRef.current && !celebrationEffectTriggered.current) {
        const pos = new THREE.Vector3().copy(character.getMesh().position)
        pos.y = 2
        visualEffectsRef.current.createCelebrationConfetti(pos)
        celebrationEffectTriggered.current = true
      }
    }
    
    // Update cinematic camera
    if (cinematicCameraRef.current) {
      cinematicCameraRef.current.updateCameraForPhase(phase, time, character.getMesh().position)
    }
      // Update current phase display
    setCurrentPhase(currentPhaseText)

    // Render
    rendererRef.current.render(sceneRef.current, cameraRef.current)

    // Check if animation is complete
    if (time >= totalDuration) {
      setIsPlaying(false)
      if (onAnimationComplete) {
        onAnimationComplete()
      }
    } else if (isPlaying) {
      setAnimationTime(prev => prev + 16)
      animationIdRef.current = requestAnimationFrame(animate)
    }
  }

  const startAnimation = () => {
    console.log('Starting animation...')
    setIsPlaying(true)
    setAnimationTime(0)
    animate()
  }

  const stopAnimation = () => {
    console.log('Stopping animation...')
    setIsPlaying(false)
    if (animationIdRef.current) {
      cancelAnimationFrame(animationIdRef.current)
      animationIdRef.current = null
    }
  }
  const resetAnimation = () => {
    stopAnimation()
    setAnimationTime(0)
    setCurrentPhase('Preparando...')
    
    // Reset effect triggers
    kickEffectTriggered.current = false
    celebrationEffectTriggered.current = false
    lastDustTime.current = 0
    
    if (characterRef.current) {
      // Reset character position
      characterRef.current.getMesh().position.set(0, 0, 0)
      
      // Reset all bone rotations
      Object.values(characterRef.current.bones).forEach(bone => {
        bone.rotation.set(0, 0, 0)
      })
    }
    
    if (ballRef.current) {
      // Reset ball position
      ballRef.current.position.set(0, 0.15, 2)
    }
    
    // Reset camera
    if (cameraRef.current) {
      cameraRef.current.position.set(0, 2, 5)
      cameraRef.current.lookAt(0, 1, 0)
    }
    
    // Clear visual effects
    if (visualEffectsRef.current) {
      visualEffectsRef.current.clearAllEffects()
    }
    
    // Render one frame to show reset state
    if (sceneRef.current && rendererRef.current && cameraRef.current) {
      rendererRef.current.render(sceneRef.current, cameraRef.current)
    }
  }

  return (
    <div className="relative w-full h-screen">
      <div ref={mountRef} className="w-full h-full" />
      
      <div className="absolute top-4 left-4 bg-black bg-opacity-75 text-white p-4 rounded-lg">
        <h3 className="text-lg font-bold mb-4">Controles da Animação</h3>
        <div className="space-y-2">
          <button 
            onClick={startAnimation} 
            disabled={isPlaying}
            className="w-full px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:bg-gray-400"
          >
            Iniciar Animação
          </button>
          <button 
            onClick={stopAnimation} 
            disabled={!isPlaying}
            className="w-full px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 disabled:bg-gray-400"
          >
            Pausar
          </button>
          <button 
            onClick={resetAnimation}
            className="w-full px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            Resetar
          </button>        </div>
        <div className="mt-4 text-sm">
          <p><strong>Tempo:</strong> {(animationTime / 1000).toFixed(1)}s / 18.0s</p>
          <p><strong>Estado:</strong> {isPlaying ? 'Rodando' : 'Parado'}</p>
          <p><strong>Fase:</strong> {currentPhase}</p>
        </div>
        
        <div className="mt-4 text-xs text-gray-300">
          <h4 className="font-bold mb-2">Técnicas demonstradas:</h4>
          <p>• <strong>FK:</strong> Rotação direta dos ossos (corrida)</p>
          <p>• <strong>IK:</strong> Posicionamento por alvo (preparação)</p>
          <p>• <strong>Hinge Joints:</strong> Limitação de ângulos (chute)</p>
          <p>• <strong>Bones:</strong> Sistema de esqueleto com 15 ossos</p>
        </div>
      </div>
    </div>
  )
}

export default FootballAnimation
